Got it üëç This is a fantastic list ‚Äî it ranges from beginner-level "learn-by-doing" projects up to serious advanced systems and compiler-level work. I‚Äôll sort them into **Beginner ‚Üí Intermediate ‚Üí Advanced** so you can see a clear roadmap of expertise progression.

---


## üü¢ Beginner (Foundations: C, C++, Game Basics, Data Structures)

These are great for getting comfortable with C/C++ and core concepts:

* Tetris Tutorial in C++ (Platform Independent)
* Space Invaders from Scratch (Parts 1‚Äì5)
* Beginning Game Programming with C++ and SDL
* Build Your Own Text Editor
* Write a hash table in C
* Build Your Own Lisp
* Build an Interpreter (Chapter 14 in C)
* Building a CHIP-8 Emulator
* How to Program an NES Game in C

---

## üü° Intermediate (Systems Programming, Graphics, Networking)

Now you‚Äôre building real systems components, graphics engines, and network protocols:

* Memory Allocators 101 - Write a simple memory allocator
* Write a Shell in C
* Implementing a Key-Value Store
* Let's Build a Simple Database
* Tiny 3D graphics projects:

  * Tiny Renderer (software rendering in 500 LOC)
  * Understandable RayTracing (256 LOC)
  * KABOOM! (180 LOC)
  * 486 LOC FPS in a weekend
* Writing a minimal x86-64 JIT compiler in C++ (Parts 1‚Äì2)
* Build a Live Code-reloader Library for C++
* OpenGL: Creating a 2D Breakout clone in C++ with OpenGL (multi-part)
* High-Performance Matrix Multiplication
* Implementing a Language with LLVM
* Meta Crush Saga: a C++17 compile-time game
* Programming concurrent servers (multi-part series)
* MQTT Broker from scratch (multi-part series)
* Let's Code a TCP/IP Stack (Parts 1‚Äì5)
* Write Your Own Virtual Machine
* Write a Bootloader in C

---

## üî¥ Advanced (OS, Compilers, Debuggers, Virtualization, Large Systems)

Here you‚Äôre deep in systems-level programming, compilers, and OS internals:

* Write an OS from scratch
* How to create an OS from scratch
* Let's Write a Kernel
* Writing a Linux Debugger (Parts 1‚Äì10)
* Linux Container in 500 Lines of Code
* Learning KVM - Implement Your Own Linux Kernel
* Build Your Own Redis with C/C++
* Write a C compiler (Parts 1‚Äì10)
* Let's write a compiler (Parts 1‚Äì8)
* Handmade Hero (full game engine from scratch)
* How to Make Minecraft in C++/OpenGL (video project)
* Write a FUSE Filesystem

---

‚úÖ That gives you a **progression path**:

1. **Beginner:** Games, interpreters, small data structures.
2. **Intermediate:** Graphics engines, networking, memory allocators, virtual machines.
3. **Advanced:** OS kernels, debuggers, compilers, containers, large-scale engines.

---

Do you want me to also **reorder them into a step-by-step roadmap** (like a sequence you can actually follow, building skill upon skill), or just keep them grouped by difficulty like this?
